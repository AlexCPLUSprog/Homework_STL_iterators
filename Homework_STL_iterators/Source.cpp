#include <iostream>
#include <vector>




int main() {

	// 1. Какую лучше структуру использовать, если мы хотим хранить пару : название книги - класс книга. 
	// При этом название книги будет уникальным, а искать по названию мы будем часто.
	
	// Для этой задачи оптимально использовать струкруру map. Выглядеть она будет вот так: std::map<std::string, class book> books;


	// 2. Почему временная сложность удаления из вектора o(n)? Объяснить подробно и понятно.
	
	// Сложность линейная, потому что если нам нужно удалить, например, 10,100 элемент и т.д, то компилятор будет считать с начала вектора, и это будет занимать приличное кол-во времени
	// Например, поиск нулевого элемента займет 0.1 мс, а поиск 100 - 0.1 * 100



	// 3. воспользуйтесь источниками и после этого своим языком объясните, почему поиск в мапе o(logn)?
	
	// Потому что поиск идет по бинарному дереву. Например, у нас 5 элементов, с ключами 2,8,5,1,3. И нам нужно найти элемент 1.
	// Копилятор не просматривает все элементы подряд, а начинается поиск с 1го элемента, дальше элементы с меньшим ключом располагаются в левой ветке, с большим - в правой.
	// 1 меньше, чем 2, поэтому мы идем в левую ветку бинарного дерева. Находим элемент с ключом 1, пропуская ключи 8,5,3. И поэтому сложность логарифмическая.

	// 4. Напишите небольшой кусок кода, который продемонстрирует инвалидацию итераторов. 
	// В комментарии поясните где и почему произошла инвалидация.

	std::vector<std::string> vec2{ "Alex", "John" }; // создали вектор стрингов с 2 переменными

	for (std::vector<std::string>::const_iterator it = vec2.begin(); it != vec2.end(); it++) {	// проходим по вектору от начала до конца
		std::cout << *it << '\n';	// выводим имена
		vec2.erase(it); // происходит инвалидация, т.к удаляем последнее значение в векторе,а итератор остался указывать на то место, где было 2 значение (т.е на пустоту)
	}
	


}